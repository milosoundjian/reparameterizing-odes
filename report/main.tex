\documentclass[oneside, a4paper, onecolumn, 11pt]{article}

% Change this: Customize the title, author, advisor, abstract
\newcommand{\thesistitle}[0]{Reparametrizing ODE models by scaling}
\newcommand{\authorname}[0]{Milos Oundjian}

\newcommand{\supervisor}[0]{Gleb Pogudin}
\newcommand{\supervisorinstitution}[0]{LIX}

\newcommand{\abstracttext}[0]{
    In this thesis, we present a novel implementation of the Hubert and Labahn algorithm for scaling invariants and symmetry reduction in dynamical systems, utilizing the Julia programming language. Our work extends the algorithm's application to non-identifiable models, offering a tool for the simplification and analysis of complex ordinary differential equation (ODE) models prevalent in the natural sciences. By integrating this implementation with the ``StructuralIdentifiability.jl'' package, we aim to make it easier for scientist to access this algorithm, enabling researchers without extensive computational backgrounds to leverage model simplification and reparameterization techniques. This approach not only facilitates the numerical solution of intricate models but also contributes to a deeper understanding of the underlying principles governing natural phenomena.
}

\usepackage[
    left=2cm,top=2.0cm,bottom=2.0cm,right=2cm,
    headheight=17pt, % as per the warning by fancyhdr
    includehead,includefoot,
    heightrounded, % to avoid spurious underfull messages
]{geometry}

% Added package
\usepackage[utf8]{inputenc}

% Template packages
\usepackage[T1]{fontenc}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{enumerate}
\usepackage{paralist}
\usepackage{xspace}
\usepackage{xcolor}
% Replace obsolete times package with mathptmx
% \usepackage{times}
\usepackage{mathptmx}
\usepackage[colorlinks, linkcolor=blue]{hyperref}
\setlength {\marginparwidth}{2.0cm}
\usepackage{pdfpages}
\usepackage{fancyhdr} %% For changing headers and footers
\usepackage{titling}
\usepackage[nottoc, numbib]{tocbibind}

% Added packages
\usepackage[framemethod=tikz]{mdframed} % For better box in abstract
\usepackage{esdiff} % For differentials
\usepackage{enumitem} % For step by step methodology
\usepackage{float} % For putting images properly
\usepackage{mathdots} % For having \iddots
\usepackage[ruled,vlined,linesnumbered]{algorithm2e} % For algorithms

% Commands
\newcommand{\Z}[0]{\mathbb{Z}}
\newcommand{\Zn}[1]{\mathbb{Z}^{#1}}
\newcommand{\Zmn}[2]{\mathbb{Z}^{#1 \times #2}}

\newcommand{\todo}[1]{
    \begin{mdframed}
        \textcolor{orange}{
        TODO: #1
        }
    \end{mdframed}
}

\newtheorem{definition}{Definition}
\newenvironment{example}[1][Example]{\textbf{#1.} }{\medskip}

\begin{document}

\hspace{0pt}
\vfill

\begin{center}
    \includegraphics[width=0.3\textwidth]{logo-EP-vertical}
    \vspace*{2em}

    {\large
        \textbf{\'Ecole Polytechnique}
        \vspace*{1em}

        \textit{BACHELOR THESIS IN COMPUTER SCIENCE}
        \vspace*{3em}

        {\Huge \textbf{\thesistitle}}
        \vspace*{3em}

        \textit{Author:}
        \vspace*{1em}

        \authorname{}, \'Ecole Polytechnique
        \vspace*{2em}

        {\textit{Advisor:}}
        \vspace*{1em}

        \supervisor{}, \supervisorinstitution{}
    }
    \vspace*{2em}

    \textit{Academic year 2023/2024}
\end{center}

\vfill
\hspace{0pt}

\newpage

\noindent\textbf{Abstract}

\begin{mdframed}
    \abstracttext{}
\end{mdframed}

\newpage

% Setting up the header
\pagestyle{fancy}
%\renewcommand{\headrulewidth}{0pt} % Remove line at top
%\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\lhead{\authorname}
%\chead{\acronym}
\rhead{\thesistitle}

\newpage
\tableofcontents
\newpage

% \pagenumbering{arabic}

\section{Introduction}


In their paper ``Scaling Invariants and Symmetry Reductions of Dynamical Systems'' \cite{Hubert2013}, they discuss the theory behind the algorithm and how it can be implemented.

\begin{align*}
    \diff{n}{t}
     & = n (r (1 - \frac{n}{K} - k \frac{p}{n + d})), \\
    \diff{p}{t}
     & = sp (1 - h \frac{p}{n})
\end{align*}

In order to do this, I implemented in Julia, the necessary functions, such as getting the Hermite Multipliers in both row and column form. Most of the references for this. These include the functions \cite{Hubert2013}

Furthermore, I was (hopefully) able to integrate this algorithm that I had implemented into a more overarching Julia library ``StructuralIdentifiability.jl''

{\color{purple}Gleb: some points to keep in mind
\begin{enumerate}
    \item mention relations to the Buckingham Pi theorem and dimension analysis
\end{enumerate}

}

% \subsection*{Notes from Week 1}


\section{Background}

\subsection{Hermite Normal Forms and Hermite Multipliers}

\subsubsection{Hermite Normal Forms (HNFs)}

While different sources may have varying definitions of Hermite Normal Forms, the ones we will follow are from \cite{Hubert2013} as they are the ones used in the definition of the algorithm.

\begin{definition}[\textit{Column} Hermite Normal Form]
    \begin{enumerate}[label=(\roman*)]
        \item The first \(r\) columns are non-zero;
        \item \(h_{k, j} = 0\) for \(k > i_j\);
        \item \(0 \le h_{i_j, k} < h_{i_j, j}\) when \(j < k\).
    \end{enumerate}
\end{definition}

\begin{definition}[\textit{Row} Hermite Normal Form]
    \begin{enumerate}[label=(\roman*)]
        \item The first \(r\) rows are non-zero;
        \item \(h_{i, k} = 0\) for \(k < j_i\);
        \item \(0 \le h_{k, j_i} < h_{i, j_i}\) when \(i < k\).
    \end{enumerate}
\end{definition}

% TODO: Fix the formatting for the definitions.

\begin{example}
    Take for example the matrix
    \[
        \begin{pmatrix}
            6 & 0 & -4 & 1  & 3 \\
            4 & 3 & 1  & -4 & 3
        \end{pmatrix}.
    \]

    The \textit{row} Hermite Normal Form of this matrix is
    \[
        \begin{pmatrix}
            2 & 6 & 6  & -9  & 3 \\
            0 & 9 & 11 & -14 & 3
        \end{pmatrix}.
    \]

    The \textit{column} Hermite Normal Form of this matrix is
    \[
        \begin{pmatrix}
            1 & 0 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 & 0
        \end{pmatrix}.
    \]
\end{example}

While they may seem similar, it is important to be careful since both of these forms are used in the algorithm, thus in this paper we will try to always be specific about which Hermite Normal Form we are using.

\subsubsection{Hermite Multipliers}

Any integer matrix \(A\) can be transformed via integer row operations (respectively column) to obtain a unique row (respectively column) Hermite Normal Form matrix H. We can encode these row operations (respectively column) into a unimodular integer matrix \(V\) such that we have \(V \cdot A = H\) (respectively \(A \cdot V = H\)). This matrix V is sometimes called the Hermite transform. In this paper we will be following \cite{Hubert2013} and calling in the \textit{Hermite Multiplier} of \(A\).

\begin{example}
    Again let us take the matrix
    \[
        A = \begin{pmatrix}
            6 & 0 & -4 & 1  & 3 \\
            4 & 3 & 1  & -4 & 3
        \end{pmatrix}.
    \]

    Its \textit{column} Hermite Normal Form is:
    \[
        H = \begin{pmatrix}
            1 & 0 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 & 0
        \end{pmatrix}.
    \]

    And a Hermite Multiplier is
    \[
        V = \begin{pmatrix}
            16  & 4  & 6   & 33  & -60 \\
            -28 & -7 & -11 & -58 & 105 \\
            24  & 6  & 9   & 50  & -90 \\
            1   & 0  & 0   & 2   & -3  \\
            0   & 0  & 0   & 0   & 1
        \end{pmatrix}.
    \]

    We can check that \(A \cdot V = H\).
\end{example}


\subsubsection{Algorithmically determining HNF and Hermite Multipliers}

There exists algorithms that can computer Hermite Normal Forms which can be found for example in \cite{cohen2013course}. The steps and complexity of this algorithm is discussed there as well. However, for the scope of this paper we will not discuss these algorithms in detail.

Effectively, we will use these algorithms as a part of our algorithm. To do this we give this algorithm a specification. The function we care about is in the Julia library \texttt{Nemo.jl} \cite{nemo} and is called \texttt{hnf\_with\_transform}. The specification of this function is as follows:

This means that in our algorithm, we already have a tool that allows us to calculate row Hermite Normal Form. What we need to do is to find a way to use this tool, for example by doing matrix operations on the input matrix \(A\) and on the result from using the function \texttt{hnf\_with\_transform} to be able to create a new function that taking input matrix \(A\), returns the column hermite normal form of \(A\). In the next section we will show how we are able to do this and prove our new method.

\begin{algorithm}[H]
    \caption{hnf\_with\_transform\_column}

    \begin{description}
        \item[Input] Integer matrix \(A\)
        \item[Output] HNF matrix \(H\) and Hermite Multiplier \(V\)
    \end{description}

    \begin{enumerate}[label = \textbf{(Step~\arabic*)}, leftmargin=*, align=left, labelsep=2pt, itemsep=0pt]
        \item Set \(m\) the number of rows of matrix \(A\) and \(r\) its rank.
        \item Reverse the rows of \(A\) then transpose \(A\).
        \item Set \(H\) and \(V\) to be the \textit{row} HNF and corresponding multiplier of \(A\).
        \item Transpose \(H\), then reverse the rows of \(H\), then reverse the first \(r\) columns of \(H\).
        \item Transpose \(V\), then reverse the rows of \(V\).
        \item Return \(H\) our \textit{column} Hermite Normal Form of the input \(A\) and \(V\) the corresponding Hermite Multiplier.
    \end{enumerate}
\end{algorithm}

The \texttt{hnf\_with\_transform} function that the Nemo library provides us with works to get the \textit{row} Hermite Normal Form of our input matrix \(A\) by doing row operations. This is due to the property of the Hermite Normal Form being found through a series of row operations on the input matrix \(A\). Similarly, the \textit{column} Hermite Normal can be found through series of column operations, so transposing \(A\) applying the \texttt{hnf\_with\_transform} and then transposing the result will allow us to effectively be using column operations (Row operations on the transpose are like column operations on the original matrix).

There are a few more details to this algorithm that are elaborated on in the next section.

\subsubsection{Explanation and Proof of Algorithm}

We start with a matrix \(A \in \Zmn{m}{n}\) of rank \(r\). We start by reversing the rows of \(A\), which is equivalent to multiplying \(A\) on the left my the \(m \times m\) matrix. The reason we do this is that later on in the algorithm we will have to reverse the rows again in order to get the proper \textit{column} Hermite Normal Form layout for the result matrix, so we have to flip the rows once in advance to cancel out the effect.
\[
    C_m = \begin{pmatrix}
        0      & \cdots  & 1      \\
        \vdots & \iddots & \vdots \\
        1      & \cdots  & 0
    \end{pmatrix}
\]
So we get the result of \(C_m A\). We then take the transpose of this to get:
\[
    (C_m A)^\intercal = A^\intercal C_m
\]

We then get the Hermite Normal Form and Hermite Multiplier of this, this is done through a series of row operations on the \(A^\intercal C_m\). We use the Nemo function \texttt{hnf\_with\_transform(A)} to do this which, gives us \(H\) the \textit{row} Hermite Normal Form of \(A\) and \(V\) a Hermite Multiplier. Thus applying this to \(A^\intercal C_m\), we get \(H\) and \(V\) such that:
\[
    V \cdot (A^\intercal C_m) = H
\]

Furthermore, since \(H\) is in \textit{row} Hermite Normal Form, we have that it follows the definition, and thus as a matrix looks something like this:
\[
    H = \left(
    \begin{array}{ccccc}
            * & \cdot & | & |      & \cdot \\
            0 & 0     & * & |      & \cdot \\
            0 & 0     & 0 & *      & \cdot \\
            0 & 0     & 0 & \cdots & 0     \\
            0 & 0     & 0 & \cdots & 0
        \end{array}
    \right)
\]

Where non first \(r\) columns are \(0\), and the \(|\) symbols show values that are \(0 \le | \le *\) To follow conditions (ii) and (iii).

Now we need to change \(H\) so that it is in \textit{column} Hermite Normal Form according to our definition and so that \(A \cdot V = H\).

To do this our next step is to take the transpose of \(H\). Taking this our new \(H^\intercal\) looks like this.
\[
    H^\intercal = \left(
    \begin{array}{ccccc}
            *     & 0     & 0     & 0      & 0      \\
            \cdot & 0     & 0     & 0      & 0      \\
            -     & *     & 0     & 0      & 0      \\
            -     & -     & *     & \vdots & \vdots \\
            \cdot & \cdot & \cdot & 0      & 0      \\
        \end{array}
    \right)
\]

We then bring flip the rows again giving us:
\[
    C_m H^\intercal = \left(
    \begin{array}{ccccc}
            \cdot & \cdot & \cdot & 0      & 0      \\
            -     & -     & *     & 0      & 0      \\
            -     & *     & 0     & 0      & 0      \\
            \cdot & 0     & 0     & \vdots & \vdots \\
            *     & 0     & 0     & 0      & 0      \\
        \end{array}
    \right)
\]

The final step is to flip the first \(r\) columns of the resulting \(C_m H^\intercal\) to get:
\[
    C_m H^\intercal C_r = \left(
    \begin{array}{ccccc}
            \cdot & \cdot & \cdot & 0      & 0      \\
            *     & -     & -     & 0      & \vdots \\
            0     & *     & -     & 0      & 0      \\
            0     & 0     & \cdot & \vdots & \vdots \\
            0     & 0     & *     & 0      & 0      \\
        \end{array}
    \right)
\]

This final result is in \textit{column} Hermite Normal Form according to our definition, so thus we have our desired result.

From the linear algebra perspective, what we did holds up. From what we had earlier:
\begin{align*}
    V \cdot (A^\intercal C_m)             & = H                   \\
    (V \cdot (A^\intercal) C_m)^\intercal & = H^\intercal         \\
    C_m A \cdot V^\intercal               & = H^\intercal         \\
    A \cdot V^\intercal C_r               & = C_m H^\intercal C_r \\
\end{align*}

We note that in our algorithm applied transpose and multiplication on the right by \(C_r\) so our resulting \(V\) is \(V^\intercal C_r\) from the original \(V\) we had from our \texttt{hnf\_with\_transform(A)} function.

It is very clear to see how it uses the steps of our algorithm to get the \textit{column} Hermite Normal Form.

\subsubsection{Normal Hermite Multiplier}

As explained earlier, the Hermite Normal Form of an integer matrix is unique, however the Hermite Multiplier itself is not, thus for any matrix

% TODO: Explain the algorithm for Normal Hermite Multiplier.

\section{Algorithm}

Now that we have a way to calculate the \textit{column} Hermite Normal Form, we can implement the algorithm to simplify the ODE equations. The proofs of the algorithm are explained in \cite{Hubert2013}, so in this we will be going over step by step each individual part of the algorithm all together to demonstrate how it is implemented in \texttt{reparametrizing-odes}.

% TODO: Complete this section.

\section{Implementation}

\begin{align*}
    \diff{x}{t}
     & = a - kx + hx^2y \\
    \diff{y}{t}
     & = b - h x^2 y
\end{align*}

I explain the process to work on this from now on.

\begin{enumerate}[label=Step \arabic*:]
    \item Form the function \(F\) with the Laurent polynomials of the differential equations.
\end{enumerate}

\subsection{Example Implementation 1}

Let us say that we are working with the Verhulst Model of Logistic growth, defined by the differential equation given by:
\[
    \diff{n}{t} = rn \left( 1 - \frac{n}{k} \right).
\]

We start by obtaining the Luarent Polynomial from this equation. By multiplying the right side by \(t\) and \(\frac{1}{n}\) we get that the Laurent Polynomial of this equation is:
\[
    r t - r k^{-1} n.
\]

Encoding this as a matrix, with the rows corresponding to the variables in the order \(r, k, t, n\), we get that our matrix
\[
    K = \begin{bmatrix}
        1 & 1  \\
        0 & -1 \\
        1 & 0  \\
        0 & 1
    \end{bmatrix}
\]

Using Proposition 5.1 from \cite{Hubert2013} we can use this matrix to determine the matrix for the scaling symmetries of our system. We recall that this means we start by finding the \textit{row} Hermite Normal Form of \(K\) and a corresponding Hermite Multiplier.

To do this we use the \texttt{hnf\_with\_transform} from Nemo \cite{nemo}, which gives us the resulting \textit{row} Hermite Normal Form of \(K\):
\[
    H = \begin{bmatrix}
        1 & 0 \\
        0 & 1 \\
        0 & 0 \\
        0 & 0
    \end{bmatrix}
\]

And a corresponding Hermite Multiplier:
\[
    U = \begin{bmatrix}
        1  & 1  & 0 & 0 \\
        0  & -1 & 0 & 0 \\
        -1 & 0  & 1 & 0 \\
        0  & 1  & 0 & 1
    \end{bmatrix}
\]

Proposition 5.1 tells us that we look at the number of zero rows of \(H\), which we call \(r\), then taking the last \(r\) rows of \(U\) gives us the matrix \(A\) which gives us a matrix that describes the scaling symmetries of the system.
\[
    A = \begin{bmatrix}
        -1 & 0 & 1 & 0 \\
        0  & 1 & 0 & 1
    \end{bmatrix}
\]

% TODO: Describe in full detail how the scaling symmetries are described here.

The final step here is to get the \textit{column} Hermite Normal Form of \(A\), which is used to determine the new system. Using the new \texttt{hnf\_with\_normal\_transform\_column} function that we implemented earlier, we can find that our Normal Hermite Multiplier and its inverse are:
\[
    V = \begin{bmatrix}
        -1 & 0 & 1 & 0  \\
        0  & 1 & 0 & -1 \\
        0  & 0 & 1 & 0  \\
        0  & 0 & 0 & 1
    \end{bmatrix}
    \quad \text{and} \quad
    W = \begin{bmatrix}
        -1 & 0 & 1 & 0 \\
        0  & 1 & 0 & 1 \\
        0  & 0 & 1 & 0 \\
        0  & 0 & 0 & 1
    \end{bmatrix}
\]

% TODO: Understand and explain the last steps in the algorithm.

\subsection{Example Implementation 2}

% TODO: Do another implementation.

\newpage
\bibliographystyle{plain}
\bibliography{main}

\newpage
\appendix

\section{Appendix}
\label{sec:appendix}

\end{document}
